<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

# 数的机器表示

## 机器字(machine word)长　　　（32/64位）
- 一般指计算机进行一次整数运算所能处理的二进制数据的位数
 - 通常也包括地址数据长度
 - 32位字长
 - 64位字长
 
## machine word在内存中的组织
- 地址按字节来定位
 - 机器字中第一个字节的地址
 - 相邻机器字的地址相差4(32-bit)或者8(64-bit)
 
## Byte Ordering (字节序)
- 一个机器字内的各个字节如何排序
 - Big Endian: Sun, PowerPC, Internet
   - 低位字节(Least significant byte, LSB)占据高地址
 - Little Endian: x86
   - 与LSB相反
   - 低地址对低位，高地址对高位
 
 ![2016-04-29 16:04:45屏幕截图.png](https://ooo.0
 o0.ooo/2016/04/29/572317882a610.png)
 
## 整数的二进制编码方式
- 无符号数
- 带符号数（补码，Two's Complement）
 - 取反加一，即得带符号数
 
### C语言中的无符号数和带符号数
- 常数(Constants)
 - 默认是带符号数
  - 如果有'U'作为后缀则是无符号数
- 混合使用，带符号数默认转换为无符号数
 - 包括比较操作符
 
### 何时采用无符号数
- 模运算
- 按位运算
- 尽量不用无符号数

## 浮点数的机器表示
- IEEE Floating Point 标准


$$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$
\\(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\\)

# x86
## 80386有三种工作模式
- 实模式  
  操作相当于一个可进行32位快速运算的8086
  
- 保护模式  
  是80x86设计目标全部达到的工作模式，通过
  对程序使用的存储区进行分段，分页的存储管理机制，
  达到分级使用，互不干扰的保护目的，能为每个任务提供一台
  虚拟处理器，使每个任务单独处理，快速切换
 
- 虚拟8086模式  
 - 保护模式下同时模拟多个8086处理器
 
## 32位微处理器的寄存器
- 8个通用寄存器
- 指令寄存器扩展为32位， EIP
- 6个段寄存器（CS DS SS ES FS GS）
- 段寄存器长度均为16位，其中13位代表内存段的一个编号，
 称为“段选择器“
 
## 保护模式下的x86（段模式）
- 支持多任务处理功能
- 支持虚拟存储器特性
- Logical Address —> Physical Address 
 - 转换起到保护作用，把一起访问的连续逻辑地址映射到分开的物理地址
 - 由 Selector（段选择器）*指明所在段* 和 Offset 完成转换
- 保护什么？
 - 分清不同任务使用的存储区域，不允许随便使用其他任务的数据和代码
 
    必要条件
  - 要标记每段存储区的所有者(进程）或被使用的权限级别
  - 要标记使用者是谁（权限级别）
  - 中间环节：CPU要去判断此次访问是否合法
  
- 在x86的保护模式下，一段内存地址是由段基地址，偏移地址两个要素构成。
- 每个段的描述（即段描述符）由三个要素构成——段基地址（32位）：段地址（20位，
  段长度单位位2^12）：访问权限
  段描述符长度为64位
- 由于系统兼容原因，段寄存器只有16位，如何表示64位的段寄存器描述符？
 - 通过描述符表：将段寄存器中的高13位值作为索引来访问该表，从而获得64位的
   段描述符。
- 段描述符表
 - GDT是全局描述符表，主要存放操作系统和各任务公用的描述符  
    GDT register（GDTR），48bit
  
 - LDT是局部描述符表，主要存放各任务的私有描述符
 - 段寄存器：高13位用来指示描述符表中的索引号，低两位是表示
 使用描述符的特权级别
 - 打开保护模式标志位，相当于按下了保护模式的开关。cr0寄存器的第0位
  就是这个开关，通过CR0_PE_ON或cr0寄存器，将第0位置1
  

# 汇编

## 汇编程序员眼中的系统结构
- 指令寄存器（PC）  
下一条指令的地址，
用EIP（X86）或 RIP（x86-64）来表示

- 寄存器与寄存器堆  
   在处理器内部的以名字来访问的快速存储单元
 
- 条件码  
  用于存储最近执行指令的结果状态信息， 用于条件指令的判断执行

## mov指令
- 简单的寻址模式
 - 间接寻址        (R)   Mem[Reg[R]]  
   寄存器R指定内存地址  
   movl (%ecx), %eax  
   (%ecx)，括号表示一个内存地址  
   把ecx的值作为内存地址来访问
   
 - 基址+偏移量 寻址     D(R)   Mem[Reg[R] + D]  
 - 变址寻址  
   
## 地址计算指令  
leal Src, Dest  
    把计算出来的地址赋给 Dest  

## 条件码
对于 t = a + b;
- CF (Carry Flag) 进位  
  可用于检测无符号整数运算的溢出
- ZF set if t == 0
- SF set if t < 0
- OF set if 补码运算溢出  
    (a>0 && b>0 && t<0) 或  
    (a<0 && b<0 && t>0)
    
## 位置对齐
- 对齐的一般原则
 - 已知某种数据类型的大小位 k 字节
 - 那么，其存储地址必须是 k 的整数倍
 - x86-64的对齐要求基本上就是这样
  - 但是32位系统，linux和windows的要求都略有不同
- 为何需要对齐
 - 计算机访问内存一般是以内存块为单位的，块的大小是地址对齐的，
   如4、8、16字节对齐等
 - 如果访问的数据跨块，会引起额外的访问
- 编译器的工作
 - 在结构的各个元素间插入额外空间来满足不同元素的对齐要求
 
- 对齐要求
 - 基本数据类型：
  - 1 byte  
    无要求
  - 2 bytes （short）  
    2字节对齐，地址最后一位为0
  - 4 bytes  （int）  
    地址最后两位是0
  - 8 bytes  （double）  
    windows & 64位的linux 都要求 8 对齐
    
 - 结构的对齐：
  - 必须满足结构中各个元素的对齐要求
  - 结构自身的对其要求等同于其各个元素中对其要求最高的那个，设为 k 字节
  - 结构的起始地址于结构长度必须是 k 的整数倍
     
## 汇编指示
- 以“.”开头的都是**汇编指示(Directives)**， 如".file", ".def",
   ".text"等，用以指示汇编器如何进行汇编。 
- 其中".file", ".def"均用于调试（可以忽略）
- 以":"结尾的字符串，是用于表示变量或函数地址的符号(Symbol)。
 - 其它均为汇编指令
 
- 示例: ".globl  main"
 - 指示汇编器符号"main"是全局的，这样同一程序的其他模块可以引用它。 
- "LC0"则不食全局可见的。

- .text   
   代码段
- .p2align 4,,15  
  指定下一行代码的对齐方式，第一参数表示按2的多少次幂字节对齐，
  第二参数表示对齐时额外空间用什么数据来填充，第三参数表示最多允许
  额外填充多少字节。  
  按16字节对齐，padding默认是0，不写
  
- .section .rdata,  "dr"    
   只读数据段
   
   
## 系统调用
- x86-Linux 下的系统调用通过中断指令（int 0x80）来实现的

- 在执行 int $0x80 指令时
 - 寄存器eax中存放的是系统调用的功能号，参数依次放到  
 ebx，ecx，edx，esi，edi中
 - 完成后，返回值可在eax中获得
 
- 参数大于5个时
 - 全部参数依次放到一块连续的内存空间中，同时edx中保存指向该内存区域的地址
 的指针

## 程序结构
- 主要包括三个常用的段：
 - .data 数据段  声明带有初始值的元素
 - .bss 数据段   声明无需初始化的元素
 - .text 正文段  程序指令， 每个汇编程序都必须包含此段
 
- 程序入口地址
 - 汇编器使用_start符号表示默认的起始点，此外如果想要汇编内部  
 的符号能够被外部模块访问，需要赋予globl属性，如：
 .globl   _start
 
## 数据段 .data
- 只读数据段 .rodata
 - 声明一个数据元素时，需要使用Symbol和类型说明
 - 示例  
   output:   # 起始地址，标号  
        .ascii "hello world."
        
   pi:  
        .float 3.14
- bss段          
 - 无需声明特定的类型
 - .comm 声明为未初始化的全局内存区域 
 - .lcomm 声明为未初始化的本地内存区域  
 - 示例  
  
        .section .bss   
          .lcomm buffer, 1000
 ## '宏'
  - .equ factor, 3
  - .equ LINUX_SYS_CALL, 0x80